================================================================================
                        WEEK 49: MASTER C STRUCTS & MEMORY
                     Complete Learning Guide with Examples
================================================================================

TABLE OF CONTENTS
=================
1. Structs Fundamentals
2. Dynamic Memory Patterns
3. File I/O with Structs
4. Common Pitfalls & Solutions
5. Real-World Project Examples

================================================================================
PART 1: STRUCTS FUNDAMENTALS
================================================================================

DEFINITION
----------
A struct is a composite data type that groups related variables together.

Example: Represent a student with multiple attributes
```c
struct Student {
    int id;
    char name[64];
    float gpa;
    char grade;
};
```

DECLARING & USING STRUCTS
--------------------------

1. METHOD 1: Define then declare
   struct Student s;  // Create variable s
   s.id = 1;
   s.gpa = 3.9;

2. METHOD 2: typedef (cleaner)
   typedef struct {
       int id;
       char name[64];
       float gpa;
   } Student;
   
   Student s;  // No need to write "struct" every time

3. METHOD 3: Self-referencing (for linked lists)
   typedef struct Node {
       int data;
       struct Node *next;  // Pointer to next node
   } Node;

SIZE AND MEMORY
---------------
sizeof(struct) may be > sum of member sizes due to PADDING

Example:
   struct Example {
       char a;      // 1 byte
       int b;       // 4 bytes
       char c;      // 1 byte
   };
   
   sizeof(struct Example) = 12 bytes (not 6!)
   
Why? The compiler aligns members for faster CPU access.

ACCESSING STRUCT MEMBERS
-------------------------

1. Direct access (for stack variables):
   struct Student s;
   s.id = 1;          // dot notation
   printf("%d\n", s.id);

2. Pointer access:
   struct Student *sp = &s;
   sp->id = 1;        // arrow notation (same as (*sp).id)
   printf("%d\n", sp->id);

3. Array of structs:
   struct Student students[10];
   students[0].id = 1;
   students[5].gpa = 3.8;

NESTED STRUCTS
--------------
One struct can contain another:

```c
typedef struct {
    int day, month, year;
} Date;

typedef struct {
    int id;
    char name[64];
    Date birthdate;  // Nested struct
} Student;

Student s;
s.birthdate.day = 15;   // Access nested member
```

COPYING STRUCTS
---------------
Unlike arrays, structs can be copied directly:

```c
Student s1 = {1, "Alice", 3.9, 'A'};
Student s2 = s1;      // Full copy (not a reference!)
s2.gpa = 2.5;         // Only s2 changes, s1 stays 3.9
```

INITIALIZING STRUCTS
---------------------

1. Partial initialization (rest = 0):
   Student s = {1, "Alice"};  // gpa and grade = 0

2. Full initialization:
   Student s = {1, "Alice", 3.9, 'A'};

3. Named initializers (C99+):
   Student s = {.id = 1, .name = "Alice", .gpa = 3.9};

4. {0} initialization (all zeros):
   Student s = {0};

================================================================================
PART 2: DYNAMIC MEMORY PATTERNS
================================================================================

MALLOC & FREE RECAP
-------------------
malloc(size) — allocates size bytes on the heap, returns pointer
free(ptr) — releases memory, returns nothing

KEY PATTERN: Single struct on heap

```c
Student *s = malloc(sizeof(Student));
if (!s) { perror("malloc"); return 1; }

s->id = 1;
strcpy(s->name, "Alice");

free(s);
s = NULL;  // Good practice: prevent use-after-free
```

PATTERN: Array of structs on heap

```c
int n = 10;
Student *students = malloc(n * sizeof(Student));
if (!students) { perror("malloc"); return 1; }

students[0].id = 1;
students[1].id = 2;

free(students);
```

PATTERN: Growable array (vector-like)

```c
typedef struct {
    Student *data;
    int count;
    int capacity;
} StudentList;

StudentList *create_list(int cap) {
    StudentList *list = malloc(sizeof(StudentList));
    list->data = malloc(cap * sizeof(Student));
    list->count = 0;
    list->capacity = cap;
    return list;
}

void destroy_list(StudentList *list) {
    free(list->data);
    free(list);
}

void add(StudentList *list, Student s) {
    if (list->count >= list->capacity) {
        int new_cap = list->capacity * 2;
        Student *tmp = realloc(list->data, new_cap * sizeof(Student));
        if (!tmp) { perror("realloc"); return; }
        list->data = tmp;
        list->capacity = new_cap;
    }
    list->data[list->count++] = s;
}
```

REALLOC PATTERN (SAFE)
----------------------
Always use a temporary pointer to avoid losing data on failure:

```c
Student *tmp = realloc(students, new_size * sizeof(Student));
if (!tmp) {
    perror("realloc");
    free(students);  // Original still valid, free it
    return NULL;
}
students = tmp;  // Now safe to update
```

LINKED LIST PATTERN
--------------------
```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// Create a node
Node *create_node(int data) {
    Node *n = malloc(sizeof(Node));
    if (!n) return NULL;
    n->data = data;
    n->next = NULL;
    return n;
}

// Insert at head
void insert_head(Node **head, int data) {
    Node *n = create_node(data);
    if (!n) return;
    n->next = *head;
    *head = n;
}

// Free entire list
void free_list(Node *head) {
    while (head) {
        Node *tmp = head;
        head = head->next;
        free(tmp);
    }
}
```

================================================================================
PART 3: FILE I/O WITH STRUCTS
================================================================================

WRITING STRUCTS TO FILE
------------------------
Use fwrite() for binary I/O:

```c
FILE *fp = fopen("students.db", "wb");
if (!fp) { perror("fopen"); return 1; }

Student s = {1, "Alice", 3.9, 'A'};
fwrite(&s, sizeof(Student), 1, fp);  // Write 1 struct

fclose(fp);
```

READING STRUCTS FROM FILE
--------------------------
Use fread():

```c
FILE *fp = fopen("students.db", "rb");
if (!fp) { perror("fopen"); return 1; }

Student s;
while (fread(&s, sizeof(Student), 1, fp) == 1) {
    printf("%d: %s (%.2f)\n", s.id, s.name, s.gpa);
}

fclose(fp);
```

WRITING ARRAYS OF STRUCTS
--------------------------
```c
StudentList *list = ...;
FILE *fp = fopen("students.db", "wb");

// Write count first (so we know how many to read)
fwrite(&list->count, sizeof(int), 1, fp);

// Write all students
fwrite(list->data, sizeof(Student), list->count, fp);

fclose(fp);
```

READING ARRAYS OF STRUCTS
--------------------------
```c
FILE *fp = fopen("students.db", "rb");

int count;
fread(&count, sizeof(int), 1, fp);

Student *students = malloc(count * sizeof(Student));
fread(students, sizeof(Student), count, fp);

fclose(fp);
```

================================================================================
PART 4: COMMON PITFALLS & SOLUTIONS
================================================================================

PITFALL 1: FORGETTING sizeof() IN CALCULATIONS
-------
❌ Wrong:
   Student *arr = malloc(10);  // Only 10 bytes!

✓ Correct:
   Student *arr = malloc(10 * sizeof(Student));

PITFALL 2: SIZEOF MISTAKES WITH POINTERS
-------
❌ Wrong:
   Student *s = malloc(sizeof(s));  // sizeof(pointer) = 8 bytes!

✓ Correct:
   Student *s = malloc(sizeof(*s));  // sizeof(Student)
   or
   Student *s = malloc(sizeof(Student));

PITFALL 3: NOT CHECKING MALLOC/REALLOC RETURN
-------
❌ Wrong:
   Student *s = malloc(sizeof(Student));
   s->id = 1;  // What if malloc failed?

✓ Correct:
   Student *s = malloc(sizeof(Student));
   if (!s) { perror("malloc"); return 1; }
   s->id = 1;

PITFALL 4: MEMORY LEAKS
-------
❌ Wrong:
   void load_students() {
       StudentList *list = malloc(...);
       // ... use list ...
       return;  // Forgot free!
   }

✓ Correct:
   void load_students() {
       StudentList *list = malloc(...);
       // ... use list ...
       free_list(list);
       return;
   }

PITFALL 5: USE-AFTER-FREE
-------
❌ Wrong:
   Student *s = malloc(...);
   free(s);
   printf("%s\n", s->name);  // Undefined behavior!

✓ Correct:
   Student *s = malloc(...);
   free(s);
   s = NULL;  // Prevent accidental reuse

PITFALL 6: DOUBLE-FREE
-------
❌ Wrong:
   free(s);
   free(s);  // Crash!

✓ Correct:
   free(s);
   s = NULL;  // Now safe (free(NULL) is safe)

PITFALL 7: REALLOC WITHOUT TEMP POINTER
-------
❌ Wrong:
   students = realloc(students, new_size);  // If fails, students is lost!

✓ Correct:
   Student *tmp = realloc(students, new_size);
   if (!tmp) {
       free(students);
       return NULL;
   }
   students = tmp;

================================================================================
PART 5: REAL-WORLD PROJECT EXAMPLES
================================================================================

PROJECT 1: STUDENT MANAGEMENT (ALREADY DONE)
See: student_management.c

Features:
- Add/list/search/sort students
- Growable array
- Automatic grade calculation
- Interactive menu

PROJECT 2: TASK TRACKER (TO BUILD)
```c
typedef struct {
    int id;
    char title[128];
    char description[512];
    int priority;  // 1-5
    int completed; // 0 or 1
} Task;
```

Features:
- Add tasks with priority
- Mark complete
- Filter by priority
- Save/load from file

PROJECT 3: CONTACT MANAGER (TO BUILD)
```c
typedef struct {
    int id;
    char name[64];
    char email[128];
    char phone[20];
    char address[256];
} Contact;
```

Features:
- Add/edit/delete contacts
- Search by name
- Export to CSV
- Import from CSV

================================================================================
LEARNING CHECKLIST
================================================================================

Structs:
☐ Understand struct definition and member access (. and ->)
☐ Use typedef to simplify struct names
☐ Understand struct copying (full copy, not reference)
☐ Know struct size is not always sum of members (padding)
☐ Nest structs and access nested members

Dynamic Memory:
☐ Always check malloc/realloc return values
☐ Use correct sizeof (sizeof(*ptr) not sizeof(ptr))
☐ Free all allocated memory
☐ Use temp pointer for realloc
☐ Set freed pointers to NULL
☐ Understand growable array pattern

File I/O:
☐ Use fwrite/fread for binary struct I/O
☐ Save count before array
☐ Handle fopen/fclose errors
☐ Test file persistence

Memory Safety:
☐ No memory leaks (valgrind --leak-check=full)
☐ No use-after-free
☐ No double-free
☐ No buffer overflows

================================================================================
NEXT STEPS
================================================================================

1. Study this guide thoroughly
2. Understand student_management.c completely
3. Build one of the suggested projects (Task Tracker or Contact Manager)
4. Test with real data
5. Commit and document
6. When ready, push entire week49 to GitHub

Questions to ask yourself:
- What happens if malloc fails?
- How do I avoid memory leaks?
- When should I use pointers vs direct access?
- How do I save and load data safely?
- What's the difference between . and -> operators?

================================================================================
