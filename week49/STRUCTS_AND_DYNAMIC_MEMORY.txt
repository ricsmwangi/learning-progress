================================================================================
     COMBINING DYNAMIC MEMORY & STRUCTS: Build a Student Management System
================================================================================

OVERVIEW
--------
This lesson teaches you how to combine structs (complex data types) with
dynamic memory (malloc/free) to build scalable, real-world applications.

KEY CONCEPTS
============

1. STRUCTS RECAP
----------------
A struct groups related data together:

  struct Student {
      int id;
      char name[64];
      float gpa;
  };

2. DYNAMIC MEMORY RECAP
-----------------------
malloc/free let us allocate memory at runtime:

  struct Student *s = malloc(sizeof(struct Student));
  if (!s) { printf("Out of memory\n"); return 1; }
  s->id = 1;
  s->name = "Alice";
  free(s);

3. COMBINING BOTH: DYNAMIC ARRAYS OF STRUCTS
---------------------------------------------
This is the power move — allocate arrays of structs that grow/shrink:

  struct Student *students = malloc(10 * sizeof(struct Student));
  students[0].id = 1;
  students[0].name = "Alice";
  
  // Later, realloc to add more
  students = realloc(students, 20 * sizeof(struct Student));

PITFALLS TO AVOID
=================

1. FORGETTING TO CHECK MALLOC RETURN
    ✗ Bad:   int *arr = malloc(sizeof(int) * n);  // What if malloc fails?
    ✓ Good:  int *arr = malloc(sizeof(int) * n);
             if (!arr) { perror("malloc"); return 1; }

2. SIZEOF MISTAKES
    ✗ Bad:   int *arr = malloc(10);  // Only 10 bytes, not 10 ints!
    ✓ Good:  int *arr = malloc(10 * sizeof(int));

3. MEMORY LEAKS (not freeing)
    ✗ Bad:   struct Student *s = malloc(...);
             // ... code ...
             return 0;  // Forgot free(s);
    ✓ Good:  struct Student *s = malloc(...);
             // ... code ...
             free(s);
             return 0;

4. USE-AFTER-FREE
    ✗ Bad:   free(s);
             printf("%s\n", s->name);  // Undefined behavior!
    ✓ Good:  free(s);
             s = NULL;  // Mark as invalid

5. REALLOC MISTAKES
    ✗ Bad:   s = realloc(s, new_size);  // If realloc fails, you lose s!
    ✓ Good:  struct Student *tmp = realloc(s, new_size);
             if (!tmp) { perror("realloc"); free(s); return 1; }
             s = tmp;

PATTERNS: GROWABLE ARRAY (Vector-like)
=======================================

struct StudentList {
    struct Student *data;
    int count;      // how many students we have
    int capacity;   // how many we can hold
};

void add_student(struct StudentList *list, struct Student s) {
    if (list->count >= list->capacity) {
        // Double capacity
        list->capacity *= 2;
        struct Student *tmp = realloc(list->data, 
                                      list->capacity * sizeof(struct Student));
        if (!tmp) { perror("realloc"); return; }
        list->data = tmp;
    }
    list->data[list->count++] = s;
}

EXERCISES
=========

1. Basic Struct + Malloc
   - Create a Student struct with id, name, gpa
   - Allocate a single Student on the heap
   - Print its info
   - Free it

2. Array of Structs
   - Create an array of 5 Students on the heap
   - Fill them with data from stdin
   - Print all students
   - Free the array

3. Growable Student List
   - Implement a StudentList (data, count, capacity)
   - Implement add_student() that grows as needed
   - Read students from stdin until "done"
   - Print final list
   - Free all memory

4. Search & Sort
   - Add search_by_name() function
   - Add sort_by_gpa() function
   - Test both

5. File Persistence
   - Save StudentList to a binary file
   - Load StudentList from a binary file
   - Handle errors gracefully

MEMORY SAFETY CHECKLIST
=======================
Before submitting any code:
☐ Every malloc has a return value check
☐ Every malloc has a corresponding free
☐ No free'd pointers are used again
☐ realloc errors are handled with a temp pointer
☐ sizeof() is used correctly (sizeof(type), not sizeof(ptr))
☐ Valgrind passes: valgrind --leak-check=full ./program

NEXT STEPS
==========
See: student_management.c for a full working example

================================================================================
